server {
    listen       80;
    listen  [::]:80;
    server_name  ${SERVER_NAME};
    server_tokens off;

    # workaround 301 redirect to localhost on folder w/o trailing slash (issued: http://host/folder -> 301 http://localhost/folder/)  
    #   https://stackoverflow.com/questions/15555428/nginx-causes-301-redirect-if-theres-no-trailing-slash
    absolute_redirect off;

    #access_log  /var/log/nginx/host.access.log  main;
    
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    location /api {
        # enables CORS to develop client agains deployed server #TODO: only for staging
        #   https://docs.unity3d.com/Manual/webgl-networking.html
        #   https://enable-cors.org/server_nginx.html
        add_header 'Access-Control-Allow-Origin' '*';
        
        proxy_pass http://server:8080/api;
    }
    
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;

        # Support Unity WebGL builds with compression and without compress fallback
        #   https://docs.unity3d.com/Manual/web-server-config-nginx.html
        
        # Add Brotli-precompressed files to your configuration file
        # On-disk Brotli-precompressed data files should be served with compression enabled:
        location ~ .+\.(data|symbols\.json)\.br$ {
            # Because this file is already pre-compressed on disk, disable the on-demand compression on it.
            # Otherwise nginx would attempt double compression.
            gzip off;
            add_header Content-Encoding br;
            default_type application/octet-stream;
        }
        # On-disk Brotli-precompressed JavaScript code files:
        location ~ .+\.js\.br$ {
            gzip off; # Do not attempt dynamic gzip compression on an already compressed file
            add_header Content-Encoding br;
            default_type application/javascript;
        }
        # On-disk Brotli-precompressed WebAssembly files:
        location ~ .+\.wasm\.br$ {
            gzip off; # Do not attempt dynamic gzip compression on an already compressed file
            add_header Content-Encoding br;
            # Enable streaming WebAssembly compilation by specifying the correct MIME type for Wasm files
            default_type application/wasm;
        }

        # Add gzip-precompressed files to your configuration files
        # On-disk gzip-precompressed data files should be served with compression enabled:
        location ~ .+\.(data|symbols\.json)\.gz$ {
            gzip off; # Do not attempt dynamic gzip compression on an already compressed file
            add_header Content-Encoding gzip;
            default_type application/gzip;
        }
        # On-disk gzip-precompressed JavaScript code files:
        location ~ .+\.js\.gz$ {
            gzip off; # Do not attempt dynamic gzip compression on an already compressed file
            add_header Content-Encoding gzip; # The correct MIME type here would be application/octet-stream, but due to Safari bug https://bugs.webkit.org/show_bug.cgi?id=247421, it's preferable to use MIME Type application/gzip instead.
            default_type application/javascript;
        }
        # On-disk gzip-precompressed WebAssembly files:
        location ~ .+\.wasm\.gz$ {
            gzip off; # Do not attempt dynamic gzip compression on an already compressed file
            add_header Content-Encoding gzip;
            # Enable streaming WebAssembly compilation by specifying the correct MIME type for Wasm files.
            default_type application/wasm;
        }

        # Add C/C++ multithreading support
        # Uncomment the following lines if build was created with "Enable Native C/C++ Multithreading" player settings
        # location ~ .+\.(htm|html|js|js\.gz|js\.br)$ {
        #     add_header Cross-Origin-Opener-Policy same-origin;
        #     add_header Cross-Origin-Embedder-Policy require-corp;
        #     add_header Cross-Origin-Resource-Policy cross-origin;
        # }

        # Uncomment the following line to allow CORS requests
        # add_header Access-Control-Allow-Origin *;
    }

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}

# Trick with variable ($ssl_server_name) helps to execute nginx without startup failure 
#   (when no certificate is generated/obtained yet)
#   https://stackoverflow.com/questions/72533030/is-it-possible-to-allow-nginx-to-start-if-the-specified-certificate-keys-files-a
#   https://serverfault.com/questions/505015/nginx-use-server-name-on-ssl-certificate-path
# Keep in mind that is it has Performance impact: "Note that using variables implies that a certificate will be loaded for each SSL handshake, and this may have a negative impact on performance. "
#   https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate
# But in original implementation (with using `default $ssl_server_name`) 
#   there are errors in logs: "cannot load certificate "/etc/letsencrypt/live//fullchain.pem": BIO_new_file() failed (SSL: error:80000002:system library::No such file or directory:calling fopen(/etc/letsencrypt/live//fullchain.pem, r) error:10000080:BIO routines::no such file) while SSL handshaking"
# So I decided to replace with always known value instead
map $ssl_server_name $_domain {
    #default $ssl_server_name;
    #~(([^\.]+)\.([^\.]+))$ $1;
    default ${SERVER_NAME};
}
server {
    listen 443 ssl;
    listen [::]:443 ssl;
    server_name ${SERVER_NAME};
    server_tokens off;

    #ssl_certificate /etc/letsencrypt/live/${SERVER_NAME}/fullchain.pem;
    #ssl_certificate_key /etc/letsencrypt/live/${SERVER_NAME}/privkey.pem;
    ssl_certificate /etc/letsencrypt/live/$_domain/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/$_domain/privkey.pem;

    http2 on;

    # best practices from by certbot
    # https://github.com/certbot/certbot/blob/main/certbot-nginx/certbot_nginx/_internal/tls_configs/options-ssl-nginx.conf
    ssl_session_cache shared:le_nginx_SSL:10m;
    ssl_session_timeout 1440m;
    ssl_session_tickets off;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers off;
    ssl_ciphers "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384";
    
    location / {
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-Host $host;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_pass http://localhost:80;
    }
}
